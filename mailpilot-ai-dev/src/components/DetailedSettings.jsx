import React, { useState, useEffect } from 'react';
import './Settings.css';

const DetailedSettings = ({ onClose }) => {
  const [structure, setStructure] = useState({});
  const [settings, setSettings] = useState({});
  const [pendingChanges, setPendingChanges] = useState({}); // Ï†ÄÏû•ÎêòÏßÄ ÏïäÏùÄ Î≥ÄÍ≤ΩÏÇ¨Ìï≠
  const [loading, setLoading] = useState(true);
  const [activeCategory, setActiveCategory] = useState('GENERAL');
  const [activeSubcategory, setActiveSubcategory] = useState('READ');
  const [saving, setSaving] = useState(false);

  // ÏÑ§Ï†ï Íµ¨Ï°∞ÏôÄ Îç∞Ïù¥ÌÑ∞ Î∂àÎü¨Ïò§Í∏∞
  useEffect(() => {
    fetchSettingsStructure();
    fetchAllSettings();
  }, []);

  const fetchSettingsStructure = async () => {
    try {
      console.log('[üéØ ÌîÑÎ°†Ìä∏] ÏÑ§Ï†ï Íµ¨Ï°∞ ÏöîÏ≤≠ ÏãúÏûë');
      const response = await fetch('http://localhost:5001/api/settings/structure', {
        credentials: 'include'
      });
      const data = await response.json();
      
      if (data.success) {
        console.log('[üéØ ÌîÑÎ°†Ìä∏] ÏÑ§Ï†ï Íµ¨Ï°∞ Î°úÎìú ÏÑ±Í≥µ:', Object.keys(data.structure));
        setStructure(data.structure);
      } else {
        console.error('[üéØ ÌîÑÎ°†Ìä∏] ÏÑ§Ï†ï Íµ¨Ï°∞ Î°úÎìú Ïã§Ìå®:', data.error);
      }
    } catch (error) {
      console.error('[üéØ ÌîÑÎ°†Ìä∏] ÏÑ§Ï†ï Íµ¨Ï°∞ Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®:', error);
    }
  };

  const fetchAllSettings = async () => {
    try {
      const userEmail = localStorage.getItem('email');
      if (!userEmail) {
        console.error('[DetailedSettings] ÏÇ¨Ïö©Ïûê Ïù¥Î©îÏùºÏù¥ ÏóÜÏäµÎãàÎã§.');
        setLoading(false);
        return;
      }
      
      const response = await fetch(`http://localhost:5001/api/settings?email=${encodeURIComponent(userEmail)}`, {
        credentials: 'include'
      });
      const data = await response.json();
      
      if (data.success) {
        setSettings(data.settings);
      }
    } catch (error) {
      console.error('[ÏÑ§Ï†ï] Îç∞Ïù¥ÌÑ∞ Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®:', error);
    } finally {
      setLoading(false);
    }
  };

  // Î≥ÄÍ≤ΩÏÇ¨Ìï≠Ïù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
  const hasChanges = () => {
    return Object.entries(pendingChanges).some(([pendingKey, pendingValue]) => {
      const [category, subcategory, fieldName] = pendingKey.split('.');
      const savedValue = settings[category]?.[subcategory]?.[fieldName];
      return pendingValue !== savedValue;
    });
  };

  // Ïã§Ï†ú Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∞úÏàò Í≥ÑÏÇ∞
  const getChangeCount = () => {
    return Object.entries(pendingChanges).filter(([pendingKey, pendingValue]) => {
      const [category, subcategory, fieldName] = pendingKey.split('.');
      const savedValue = settings[category]?.[subcategory]?.[fieldName];
      return pendingValue !== savedValue;
    }).length;
  };

  // ÌòÑÏû¨ Í∞í Í∞ÄÏ†∏Ïò§Í∏∞ (Ï†ÄÏû•Îêú Í∞í + Î≥ÄÍ≤ΩÏÇ¨Ìï≠)
  const getCurrentValue = (category, subcategory, fieldName, fieldInfo) => {
    const pendingKey = `${category}.${subcategory}.${fieldName}`;
    if (pendingChanges[pendingKey] !== undefined) {
      return pendingChanges[pendingKey];
    }
    const savedValue = settings[category]?.[subcategory]?.[fieldName];
    // Í∞íÏù¥ ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©
    if (savedValue === undefined || savedValue === null) {
      return fieldInfo?.default;
    }
    return savedValue;
  };

  // ÌïÑÎìú Î≥ÄÍ≤Ω (Î°úÏª¨ ÏÉÅÌÉúÎßå ÏóÖÎç∞Ïù¥Ìä∏)
  const handleFieldChange = (category, subcategory, fieldName, value) => {
    console.log(`[üéØ ÌîÑÎ°†Ìä∏] ÏÑ§Ï†ï Î≥ÄÍ≤Ω (Î°úÏª¨): ${category}/${subcategory}/${fieldName} = ${value}`);
    const pendingKey = `${category}.${subcategory}.${fieldName}`;
    
    setPendingChanges(prev => ({
      ...prev,
      [pendingKey]: value
    }));
  };

  // Î™®Îì† Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï†ÄÏû•
  const handleSaveAll = async () => {
    if (!hasChanges()) return;
    
    console.log('[üéØ ÌîÑÎ°†Ìä∏] Î™®Îì† Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï†ÄÏû• ÏãúÏûë');
    setSaving(true);
    
    try {
      const userEmail = localStorage.getItem('email');
      
      // Ïã§Ï†úÎ°ú Î≥ÄÍ≤ΩÎêú Í≤ÉÎßå ÌïÑÌÑ∞ÎßÅ
      const actualChanges = Object.entries(pendingChanges).filter(([pendingKey, pendingValue]) => {
        const [category, subcategory, fieldName] = pendingKey.split('.');
        const savedValue = settings[category]?.[subcategory]?.[fieldName];
        return pendingValue !== savedValue;
      });
      
      for (const [pendingKey, value] of actualChanges) {
        const [category, subcategory, fieldName] = pendingKey.split('.');
        const url = `http://localhost:5001/api/settings/${category}/${subcategory}/${fieldName}`;
        
        console.log(`[üéØ ÌîÑÎ°†Ìä∏] API ÏöîÏ≤≠: PUT ${url} = ${value}`);
        
        const response = await fetch(url, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          credentials: 'include',
          body: JSON.stringify({ 
            value,
            email: userEmail 
          })
        });
        
        const data = await response.json();
        
        if (!data.success) {
          throw new Error(`${category}/${subcategory}/${fieldName} Ï†ÄÏû• Ïã§Ìå®: ${data.error}`);
        }
      }
      
      // ÏÑ±Í≥µÏãú Ïã§Ï†ú ÏÑ§Ï†ïÏóê Î∞òÏòÅÌïòÍ≥† Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï¥àÍ∏∞Ìôî
      const newSettings = { ...settings };
      for (const [pendingKey, value] of actualChanges) {
        const [category, subcategory, fieldName] = pendingKey.split('.');
        if (!newSettings[category]) newSettings[category] = {};
        if (!newSettings[category][subcategory]) newSettings[category][subcategory] = {};
        newSettings[category][subcategory][fieldName] = value;
      }
      
      setSettings(newSettings);
      setPendingChanges({});
      
      console.log('[‚úÖ ÌîÑÎ°†Ìä∏] Î™®Îì† ÏÑ§Ï†ï Ï†ÄÏû• ÏôÑÎ£å');
      
      // ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏ Ïù¥Î≤§Ìä∏ Î∞úÏÉù (WriteMail Îì± Îã§Î•∏ Ïª¥Ìè¨ÎÑåÌä∏Ïóê ÏïåÎ¶º)
      window.dispatchEvent(new Event('settingsUpdated'));
      
      alert('‚úÖ ÏÑ§Ï†ïÏù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.');
      
    } catch (error) {
      console.error('[‚ùå ÌîÑÎ°†Ìä∏] ÏÑ§Ï†ï Ï†ÄÏû• Ïã§Ìå®:', error);
      alert('‚ùå ÏÑ§Ï†ï Ï†ÄÏû• Ïã§Ìå®: ' + error.message);
    } finally {
      setSaving(false);
    }
  };

  // Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï∑®ÏÜå
  const handleCancelChanges = () => {
    console.log('[üéØ ÌîÑÎ°†Ìä∏] Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï∑®ÏÜå');
    setPendingChanges({});
  };

  // ÌïÑÎìú Î†åÎçîÎßÅ
  const renderField = (category, subcategory, fieldName, fieldInfo) => {
    const fieldId = `${category}-${subcategory}-${fieldName}`;
    const currentValue = getCurrentValue(category, subcategory, fieldName, fieldInfo);
    const pendingKey = `${category}.${subcategory}.${fieldName}`;
    
    // Î≥ÄÍ≤Ω ÏÉÅÌÉú ÌôïÏù∏: pendingChangesÏóê ÏûàÍ≥†, Ï†ÄÏû•Îêú Í∞íÍ≥º Îã§Î•∏ Í≤ΩÏö∞ÏóêÎßå Î≥ÄÍ≤ΩÏúºÎ°ú ÌëúÏãú
    const savedValue = settings[category]?.[subcategory]?.[fieldName];
    const pendingValue = pendingChanges[pendingKey];
    const hasChange = pendingValue !== undefined && pendingValue !== savedValue;
    
    const handleChange = (newValue) => {
      handleFieldChange(category, subcategory, fieldName, newValue);
    };

    switch (fieldInfo.type) {
      case 'checkbox':
        return (
          <div key={fieldName} className={`setting-item ${hasChange ? 'changed' : ''}`}>
            <label htmlFor={fieldId}>
              <input
                id={fieldId}
                type="checkbox"
                checked={currentValue || false}
                onChange={(e) => handleChange(e.target.checked)}
                disabled={saving}
              />
              {fieldInfo.label}
              {hasChange && <span className="change-indicator">‚óè</span>}
            </label>
          </div>
        );

      case 'radio':
        return (
          <div key={fieldName} className={`setting-item ${hasChange ? 'changed' : ''}`}>
            <label className="setting-label">
              {fieldInfo.label}
              {hasChange && <span className="change-indicator">‚óè</span>}
            </label>
            <div className="radio-group">
              {fieldInfo.options?.map(option => (
                <label key={option.value} className="radio-option">
                  <input
                    type="radio"
                    name={fieldId}
                    value={option.value}
                    checked={currentValue === option.value}
                    onChange={(e) => handleChange(e.target.value)}
                    disabled={saving}
                  />
                  {option.label}
                </label>
              ))}
            </div>
          </div>
        );

      case 'select':
        return (
          <div key={fieldName} className={`setting-item ${hasChange ? 'changed' : ''}`}>
            <label htmlFor={fieldId}>
              {fieldInfo.label}
              {hasChange && <span className="change-indicator">‚óè</span>}
            </label>
            <select
              id={fieldId}
              value={currentValue || fieldInfo.default || ''}
              onChange={(e) => handleChange(e.target.value)}
              disabled={saving}
            >
              {fieldInfo.options?.map(option => (
                <option key={option.value} value={option.value}>{option.label}</option>
              ))}
            </select>
          </div>
        );

      case 'number':
        return (
          <div key={fieldName} className={`setting-item ${hasChange ? 'changed' : ''}`}>
            <label htmlFor={fieldId}>
              {fieldInfo.label}
              {hasChange && <span className="change-indicator">‚óè</span>}
            </label>
            <input
              id={fieldId}
              type="number"
              min={fieldInfo.min}
              max={fieldInfo.max}
              step={fieldInfo.step || 1}
              value={currentValue !== undefined && currentValue !== null ? currentValue : (fieldInfo.default || '')}
              onChange={(e) => {
                const value = e.target.value;
                // Îπà Î¨∏ÏûêÏó¥Ïù¥Î©¥ undefinedÎ°ú Ï≤òÎ¶¨, ÏïÑÎãàÎ©¥ Ïà´ÏûêÎ°ú Î≥ÄÌôò
                handleChange(value === '' ? undefined : parseInt(value));
              }}
              disabled={saving}
            />
          </div>
        );

      case 'text':
        return (
          <div key={fieldName} className={`setting-item ${hasChange ? 'changed' : ''}`}>
            <label htmlFor={fieldId}>
              {fieldInfo.label}
              {hasChange && <span className="change-indicator">‚óè</span>}
            </label>
            <input
              id={fieldId}
              type="text"
              placeholder={fieldInfo.placeholder}
              value={currentValue || ''}
              onChange={(e) => handleChange(e.target.value)}
              disabled={saving}
            />
          </div>
        );

      case 'checkbox_group':
        return (
          <div key={fieldName} className="setting-item">
            <label className="setting-label">{fieldInfo.label}</label>
            <div className="checkbox-group">
              {fieldInfo.options?.map(option => (
                <label key={option.value} className="checkbox-option">
                  <input
                    type="checkbox"
                    checked={(currentValue || []).includes(option.value)}
                    onChange={(e) => {
                      const newValue = currentValue || [];
                      if (e.target.checked) {
                        handleChange([...newValue, option.value]);
                      } else {
                        handleChange(newValue.filter(v => v !== option.value));
                      }
                    }}
                    disabled={saving}
                  />
                  {option.label}
                </label>
              ))}
            </div>
          </div>
        );

      case 'signature_list':
        // getCurrentValueÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ìè¨Ìï®Îêú Í∞í Í∞ÄÏ†∏Ïò§Í∏∞
        const currentSignatures = getCurrentValue(activeCategory, activeSubcategory, 'signatures', fieldInfo) || [];
        const currentSignature = currentSignatures[0] || {};
        const signatureEnabled = getCurrentValue(activeCategory, activeSubcategory, 'enabled', { default: true });
        
        return (
          <div key={fieldName} className="setting-item">
            <label className="setting-label">{fieldInfo.label}</label>
            
            {/* ÏÑúÎ™Ö ÏÇ¨Ïö© Ïó¨Î∂Ä */}
            <div className="signature-toggle" style={{ marginBottom: '15px' }}>
              <label>
                <input
                  type="checkbox"
                  checked={signatureEnabled !== false}
                  onChange={(e) => {
                    handleFieldChange(activeCategory, activeSubcategory, 'enabled', e.target.checked);
                  }}
                />
                ÏÑúÎ™Ö ÏÇ¨Ïö©
              </label>
            </div>

            {/* ÏÑúÎ™Ö ÎÇ¥Ïö© ÏûÖÎ†• */}
            <div className="signature-content">
              <label>ÏÑúÎ™Ö ÎÇ¥Ïö©:</label>
              <textarea
                value={currentSignature.content || ''}
                onChange={(e) => {
                  const updatedSignature = {
                    id: 1,
                    name: 'ÎÇ¥ ÏÑúÎ™Ö',
                    content: e.target.value,
                    html_content: '',
                    is_html: false,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                  };
                  handleFieldChange(activeCategory, activeSubcategory, 'signatures', [updatedSignature]);
                }}
                placeholder="ÏµúÏàòÏö¥&#10;MailPilot AI Í∞úÎ∞úÌåÄ&#10;csw21c915@gmail.com&#10;010-1234-5678"
                rows={6}
                style={{
                  width: '100%',
                  padding: '10px',
                  border: '1px solid #ddd',
                  borderRadius: '4px',
                  fontFamily: 'inherit',
                  fontSize: '14px',
                  resize: 'vertical'
                }}
              />
            </div>
          </div>
        );


      default:
        return null;
    }
  };

  // ÌÖåÎßà ÏÑπÏÖò Î†åÎçîÎßÅ
  const renderThemeSection = () => {
    const currentTheme = getCurrentValue('GENERAL', 'THEME', 'appearance', { default: 'light' });
    const hasChange = pendingChanges['GENERAL.THEME.appearance'] !== undefined && 
                     pendingChanges['GENERAL.THEME.appearance'] !== settings?.GENERAL?.THEME?.appearance;

    return (
      <div className="settings-sections">
        <div className="settings-section">
          <h4>üåô ÌÖåÎßà ÏÑ§Ï†ï</h4>
          <div className="section-fields">
            <div className={`setting-item ${hasChange ? 'changed' : ''}`}>
              <label className="setting-label">
                ÌÖåÎßà Î™®Îìú
                {hasChange && <span className="change-indicator">‚óè</span>}
              </label>
              <div className="radio-group">
                <label className="radio-option">
                  <input
                    type="radio"
                    name="theme-mode"
                    value="light"
                    checked={currentTheme === 'light'}
                    onChange={(e) => handleFieldChange('GENERAL', 'THEME', 'appearance', 'light')}
                    disabled={saving}
                  />
                  ‚òÄÔ∏è ÎùºÏù¥Ìä∏ Î™®Îìú
                </label>
                <label className="radio-option">
                  <input
                    type="radio"
                    name="theme-mode"
                    value="dark"
                    checked={currentTheme === 'dark'}
                    onChange={(e) => handleFieldChange('GENERAL', 'THEME', 'appearance', 'dark')}
                    disabled={saving}
                  />
                  üåô Îã§ÌÅ¨ Î™®Îìú
                </label>
                <label className="radio-option">
                  <input
                    type="radio"
                    name="theme-mode"
                    value="auto"
                    checked={currentTheme === 'auto'}
                    onChange={(e) => handleFieldChange('GENERAL', 'THEME', 'appearance', 'auto')}
                    disabled={saving}
                  />
                  üîÑ ÏãúÏä§ÌÖú ÏÑ§Ï†ï Îî∞Î•¥Í∏∞
                </label>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  };

  // ÏÑπÏÖò Î†åÎçîÎßÅ
  const renderSection = (category, subcategory) => {
    // ÌÖåÎßà ÏÑπÏÖòÏùÄ ÌäπÎ≥Ñ Ï≤òÎ¶¨
    if (category === 'GENERAL' && subcategory === 'THEME') {
      return renderThemeSection();
    }

    const subcategoryData = structure[category]?.[subcategory];
    const settingsData = settings[category]?.[subcategory] || {};

    if (!subcategoryData || !subcategoryData.sections) {
      return <div>ÏÑ§Ï†ïÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë...</div>;
    }

    return (
      <div className="settings-sections">
        {Object.entries(subcategoryData.sections).map(([sectionKey, sectionData]) => (
          <div key={sectionKey} className="settings-section">
            <h4>{sectionData.name}</h4>
            <div className="section-fields">
              {Object.entries(sectionData.fields).map(([fieldName, fieldInfo]) => {
                // showIf Ï°∞Í±¥ Ï≤¥ÌÅ¨
                if (fieldInfo.showIf) {
                  const [conditionField, conditionValue] = Object.entries(fieldInfo.showIf)[0];
                  if (settingsData[conditionField] !== conditionValue) {
                    return null;
                  }
                }
                
                return renderField(
                  category,
                  subcategory,
                  fieldName,
                  fieldInfo
                );
              })}
            </div>
          </div>
        ))}
      </div>
    );
  };

  if (loading) {
    return (
      <div className="settings-overlay">
        <div className="settings-container">
          <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
            <p>ÏÑ§Ï†ïÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë...</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="settings-overlay">
      <div className="settings-container detailed-settings">
        <div className="settings-header">
          <h2>ÏÑ§Ï†ï</h2>
          <button className="close-btn" onClick={onClose}>‚úï</button>
        </div>

        <div className="settings-content">
          <div className="settings-sidebar">
            <ul>
              {/* ÏùºÎ∞ò ÏÑ§Ï†ï */}
              <li className={activeCategory === 'GENERAL' ? 'active' : ''}>
                <div 
                  className="category-title"
                  onClick={() => setActiveCategory('GENERAL')}
                >
                  ÏùºÎ∞ò
                </div>
                {activeCategory === 'GENERAL' && (
                  <ul className="subcategory-list">
                    <li 
                      className={activeSubcategory === 'READ' ? 'active' : ''}
                      onClick={() => setActiveSubcategory('READ')}
                    >
                      ÏùΩÍ∏∞
                    </li>
                    <li 
                      className={activeSubcategory === 'WRITE' ? 'active' : ''}
                      onClick={() => setActiveSubcategory('WRITE')}
                    >
                      Ïì∞Í∏∞
                    </li>
                    <li 
                      className={activeSubcategory === 'THEME' ? 'active' : ''}
                      onClick={() => setActiveSubcategory('THEME')}
                    >
                      ÌÖåÎßà
                    </li>
                  </ul>
                )}
              </li>

              {/* ÎÇ¥ Î©îÏùº ÏÑ§Ï†ï */}
              <li className={activeCategory === 'MY_EMAIL' ? 'active' : ''}>
                <div 
                  className="category-title"
                  onClick={() => setActiveCategory('MY_EMAIL')}
                >
                  ÎÇ¥ Î©îÏùº
                </div>
                {activeCategory === 'MY_EMAIL' && (
                  <ul className="subcategory-list">
                    <li 
                      className={activeSubcategory === 'SIGNATURE_MANAGEMENT' ? 'active' : ''}
                      onClick={() => setActiveSubcategory('SIGNATURE_MANAGEMENT')}
                    >
                      ÏÑúÎ™Ö Í¥ÄÎ¶¨
                    </li>
                  </ul>
                )}
              </li>
            </ul>
          </div>

          <div className="settings-main">
            <div className="settings-content-header">
              <h3>
                {structure[activeCategory]?.[activeSubcategory]?.name || activeSubcategory}
              </h3>
              {saving && <span className="saving-indicator">Ï†ÄÏû• Ï§ë...</span>}
            </div>
            
            {renderSection(activeCategory, activeSubcategory)}
          </div>
        </div>

        <div className="settings-footer">
          <div className="footer-left">
            {hasChanges() && (
              <span className="changes-indicator">
                üîÑ {getChangeCount()}Í∞ú Î≥ÄÍ≤ΩÏÇ¨Ìï≠
              </span>
            )}
          </div>
          <div className="footer-right">
            <button 
              className="btn-cancel" 
              onClick={handleCancelChanges}
              disabled={!hasChanges() || saving}
            >
              Ï∑®ÏÜå
            </button>
            <button 
              className="btn-save" 
              onClick={handleSaveAll}
              disabled={!hasChanges() || saving}
            >
              {saving ? 'Ï†ÄÏû• Ï§ë...' : 'Ï†ÄÏû•'}
            </button>
            <button className="btn-close" onClick={onClose}>Îã´Í∏∞</button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default DetailedSettings;